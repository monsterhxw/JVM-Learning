# JVM
## 01 | Java 代码是怎么运行的
**JRE : Java 运行时环境，JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机 以及 Java 核心类库等。**

**JDK : Java 开发工具包，包含了 JRE ，并且还附带了一系列开发、诊断工具。**

### 1、为什么 Java 要在虚拟机里运行？
- **JVM 提供了可移植性，可以轻松实现 Java 代码的跨平台执行。**
 - Java 虚拟机，在各个现有平台（如 Windows、Linux、Mac OS）上提供软件实现，一旦一个 Java 程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。实现“一次编写，到处运行”。
- **JVM 提供了一个托管环境（Managed Runtime），提供自动内存管理、垃圾回收、编译时动态校验（如数组越界、动态类型、安全权限等）等功能，使我们免于书 写这些无关业务逻辑的代码。**

### 2、Java 虚拟机具体是怎么样运行 Java 字节码的？
以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度来说明 Java 虚拟机具体是怎么样运行 Java 字节码的。
#### 虚拟机角度：
**虚拟机执行 Java 代码 首先需要将它编译成 class 文件（字节码文件）然后加载到 Java 虚拟机中的方法区（Method Area），方能在 Java 虚拟机中运行。**

Java 虚拟机在内存中划分出**堆**和**栈**来存储运行时数据。

- Java 虚拟机将**栈**细分为：
	
  1. 面向 Java 方法的 **Java 方法栈**。
	  
  2. 面向本地方法（用 C++ 写的 native 方法）的**本地方法栈**。
	  
  3. 以及存放各个线程执行位置的 **PC 寄存器**。
	  
  在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个**栈帧**，用以存放**局部变量**以及**字节码的操作数**。

  这个**栈帧**是提前计算好的，而且 Java 虚拟机**不要求栈帧在内存空间里连续分布**。

  当**退出当前执行的方法时**，不管是正常返回还是异常返回，Java 虚拟机均会**弹出当前线程的当前栈帧**，并将之舍弃。
![jvm_run](/Users/monstervivi/Desktop/JVM/images/jvm_run.png)

#### 硬件角度：
**Java 字节码无法直接运行。所以 Java 虚拟机需要将字节码翻译成为机器码。**

在 HotSpot 虚拟机里面，字节码翻译为机器码的过程有2种形式：

- 解释执行：即逐条将字节码翻译成机器码并执行。

- 即时编译（Just-In-Time compilation, JIT）：即将一个方法中包含的所有字节码编译成机器码后再执行。

**解释执行的优势在于无需等待编译，而即时编译的优势在于实际运行速度更快**。

HotSpot 虚拟机为了**提高运行效率，默认采用混合模式**，综合了解释和即时编译两者的优点。它会**先解释执行字节码**，而**后将其中反复执行的热点代码，以方法为单位进行即时编译**，翻译成机器码后直接运行在底层硬件之上。

HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。
![jvm_compilation](/Users/monstervivi/Desktop/JVM/images/jvm_compilation.png)